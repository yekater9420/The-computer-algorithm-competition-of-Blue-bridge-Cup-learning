# 皇后问题
'''
有一个NN的矩阵方格和N个棋了，现在需要将N个棋了按要求放置到知阵方格中。要求如下:
1.任意两个棋了不能在同一行
2.任意两个棋子不能在同一列
3.任意两个棋子不能在同一对角线上(下图红色线段都为对角线)
根据以上要求，问N个棋子放置到N*N矩阵方格中有多少种放置方案
输入描述:输出描述:
例如:4*4的矩阵方格，4个棋子，有2种放置方案
-----------------------
0 1 0 0   |    0 0 1 0
0 0 0 1   |    1 0 0 0
1 0 0 0   |    0 0 0 1
0 0 1 0   |    0 1 0 0
-----------------------
输入一个正整数N(1<N<11)，表示一个N”N的矩阵方格和N个棋子数量
输出N个棋子按要求放置到N”N的矩阵方格中有多少种放置方案
样例输入:4
样例输出:2
'''
UP = 'https://www.bilibili.com/video/BV16M411M72d/?p=11&spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=c4c31c471fa6e78618db0c0a142f20fb'
'''
4 ----> 2
8 ----> 92
16----> 143090
'''
'''
主对角线:main dialog
副对角线:sub dialog
'''
'''
主对角线:行号-列号=常数
副对角线:行号+列号=常数
主对角线:0-0 0-1 0-2 0-3 1-0 1-1 1-2 1-3 2-0 2-1 2-2 2-3 3-0 3-1 3-2 3-3
副对角线:0+0 0+1 0+2 0+3 1+0 1+1 1+2 1+3 2+0 2+1 2+2 2+3 3+0 3+1 3+2 3+3
主对角线:x - y + n - 1              有 2n-1 条
副对角线:x + y
'''
'''
搜索策略+回溯+函数
'''
# 代码部分
n = 4

maindiag = [0 for x in range(2 * n - 1)]   # 主对角线有2n-1条.标记为0
subdiag = [0 for x in range(2 * n - 1)]    # 副对角线有2n-1条.标记为0

column = [0 for x in range(n)]             # 列号[0,0,0,0]
rows = [-1 for x in range(n)]              # 行号[0,0,0,0]

def search(row):   #0行
    for col in range(n):  #0列
        x = row ; y = col
        if maindiag[x - y + n - 1] == 0 and subdiag[x + y] == 0 and column[col] == 0: # 检测主对角线,副对角线,列
            rows[row] = col # 在第rol行,在第col列放置一个皇后[0 , n-1]
            maindiag[x - y + n - 1] = 10  # 这个位置主对角线被占用
            subdiag[x + y] = 1  # 这个位置副对角线被占用
            column[col] = 1  # 当前列标记被占用

            if row < n - 1: # 如果不是最后一行
                search(row + 1)  # 递归调用,搜索下一行
            else:  # 如果是最后一行，row == n-1
                print("found")  # 输出结果

            maindiag[x - y + n - 1] = 0  # 回溯 这个主对角线取消占用
            subdiag[x + y] = 0  # 回溯 这个副对角线取消占用
            column[col] = 0  # 回溯 当前列取消占用
            rows[row] = -1  # 回溯 当前行取消占用
search(0)            










